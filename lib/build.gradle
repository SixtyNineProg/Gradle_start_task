import java.time.LocalDate

plugins {
    id 'java'
    id 'jacoco'
}

sourceSets {
    main {
        java {
            srcDirs = ['src/java']
        }
        resources {
            srcDirs = ['src/resources']
        }
    }
}

ext {
    javaVersion = 17
    currentDate = LocalDate.now()
}
//println ext.javaVersion
//println project.javaVersion
//println project.ext.javaVersion
println 'java version: ' + javaVersion
//println '-------- All properties:'
//println project.properties
//println '-------- System:'
//println System.getProperty('sys.example')
//RUN gradle third -D'sys.example'=sysValue1 -PprojectParam1=projectValue1

repositories {
    mavenCentral()
}

apply from: 'gradle/taks/taskHello.gradle'
apply from: 'gradle/taks/taskFirst.gradle'
apply from: 'gradle/taks/taskSecond.gradle'
apply from: 'gradle/taks/taskThird.gradle'
apply from: 'gradle/taks/taskFourth.gradle'
apply from: 'gradle/taks/taskFifth.gradle'

apply plugin: GreetingPlugin

class GreetingPlugin implements Plugin<Project> {
    @Override
    void apply(Project project) {
        def map = [desctiption: "Greeting task", group: "klimov", type: DefaultTask]
        project.tasks.register("greeting") {
            doLast {
                System.out.println("Hello Gradle!")
            }
        }
    }
}

second.dependsOn(first)

// In Gradle, mustRunAfter and shouldRunAfter are both used to specify the order of execution of tasks.
// However, they differ in their strictness of ordering.
//
// When you use the mustRunAfter ordering rule, you specify that taskB must always run after taskA,
// whenever both taskA and taskB will be run. This is expressed as taskB.mustRunAfter(taskA).
//
// On the other hand, the shouldRunAfter ordering rule is similar but less strict as it will be ignored in two situations.
// Firstly, if using that rule introduces an ordering cycle. Secondly, when using parallel execution and all
// dependencies of a task have been satisfied apart from the shouldRunAfter task, then this task will be run
// regardless of whether its shouldRunAfter dependencies have been run or not.
// You should use shouldRunAfter where the ordering is helpful but not strictly required.
// Command: gradle third fourth
third.mustRunAfter(fourth)
third.shouldRunAfter(fourth)

second.finalizedBy(third)

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    println "----------- Graph:"
    graph.allTasks.each {
        println "{$it.name}"
    }
}

//Task Graph callback
//gradle.taskGraph.beforeTask { task ->
//    println "before callback first $task"
//}
//
//gradle.taskGraph.afterTask { task ->
//    println "after callback first $task"
//}

gradle.taskGraph.whenReady { TaskExecutionGraph taskExecutionGraph ->
    taskExecutionGraph.getAllTasks().each { Task task ->
        task.doFirst {
            println "before callback second $task"
        }

        task.doLast {
            println "after callback second $task"
        }
    }
}

defaultTasks 'first'

tasks.named('test') {
    useJUnitPlatform()
}

version = '1.0.0'

tasks.named('jar') {
    manifest {
        attributes('Implementation-Title': project.name,
                'Implementation-Version': project.version)
    }
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
    compileOnly group: 'org.projectlombok', name: 'lombok', version: '1.18.30'
}

test {
    finalizedBy jacocoTestReport // report is always generated after tests run
}

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.5
            }
        }

        rule {
            enabled = false
            element = 'CLASS'
            includes = ['org.gradle.*']

            limit {
                counter = 'LINE'
                value = 'TOTALCOUNT'
                maximum = 0.3
            }
        }
    }
}